//Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
//Licensed under the Universal Permissive License (UPL) Version 1.0 as shown at http://oss.oracle.com/licenses/upl.

package testutil

import (
	"os"
	"strconv"
	"strings"
	"testing"
	"time"
)

var TestLog *testing.T

//TestCase struct
type TestCase struct {
	Name           string                                            //Required. test name
	Enabled        bool                                              //Required. test case would be execute or not
	Executer       func() TestExecuter                               //Required. function to get the client, if not specified, default client would be created accroding to the type of Data
	Method         string                                            //Method for current Testing
	Data           interface{}                                       //Required. The input/output and func used during the test
	PreTestFunc    func(data interface{}, context *TestContext)      //Optional. function executed before test. Optional
	PostTestFunc   func(data interface{}, context *TestContext)      //Optional. function executed after test/ If not specified, default func would be used
	VerifyTestFunc func(data interface{}, context *TestContext) bool //Optional. function executed to verify test result. If not specified, default func would be used
}

//Set PreTestFunc if PreTestFunc is nil
func (tc *TestCase) SetPreTestFunc(curFunc func(data interface{}, context *TestContext)) {
	if tc.PreTestFunc == nil {
		tc.PreTestFunc = curFunc
	}
}

//Set PostTestFunc if PostTestFunc is nil
func (tc *TestCase) SetPostTestFunc(curFunc func(data interface{}, context *TestContext)) {
	if tc.PostTestFunc == nil {
		tc.PostTestFunc = curFunc
	}
}

//Set VerifyTestFunc if VerifyTestFunc is nil
func (tc *TestCase) SetVerifyTestFunc(curFunc func(data interface{}, context *TestContext) bool) {
	if tc.VerifyTestFunc == nil {
		tc.VerifyTestFunc = curFunc
	}
}

//Test context
type TestContext struct {
	NameIDMap     map[string]string      //Name:ID map. Name is specified by user, ID is generated by speedle
	NameObjectMap map[string]interface{} //Name:Object map.
	FileName      string                 //File Name used in test
}

//Test Executer interface
type TestExecuter interface {
	PreExecute(testcase *TestCase, context *TestContext) (err error)
	Execute(testcase *TestCase, context *TestContext) (err error)
}

//Run a group of Test cases
func RunTestCases(t *testing.T, testcases *[]TestCase, ctx *TestContext) {
	context := ctx
	if context == nil {
		context = &TestContext{
			NameIDMap:     make(map[string]string),
			NameObjectMap: make(map[string]interface{}),
		}
	}

	for _, tc := range *testcases {
		TestLog = t

		if true { //tc.Enabled){

			t.Logf("======Begin to run test case: %s \n", tc.Name)

			//If test case name is like sleep_500, then it would sleep 500ms
			method := strings.ToLower(tc.Method)
			if strings.Contains(method, "sleep") {
				sleep, _ := strconv.Atoi(method[6:])
				t.Logf("Sleep %d mill-secondes", sleep)
				time.Sleep(time.Duration(sleep) * time.Millisecond)
				continue
			}

			var runner TestExecuter
			if tc.Executer != nil {
				runner = tc.Executer()
			} else {
				t.Fatalf("No Executer specified in test cases")
			}
			t.Run(tc.Name, testcaseFunc(runner, context, &tc))

		}
	}
}

//Function to run test case
func testcaseFunc(runner TestExecuter, context *TestContext, tc *TestCase) func(*testing.T) {
	return func(t *testing.T) {
		TestLog = t

		err := runner.PreExecute(tc, context)
		if err != nil {
			t.Fatalf("Client pre-Execute test failed. Err=%s", err)
		}

		//process the data before running Test if preTestFunc if not nil
		if tc.PreTestFunc != nil {
			tc.PreTestFunc(tc.Data, context)
		}

		//Do the action by client
		err = runner.Execute(tc, context)
		if err != nil {
			t.Fatalf("Client Execute test failed. Err=%s", err)
		}

		//process the data after running Test if postTestFunc if not nil
		if tc.PostTestFunc != nil {
			tc.PostTestFunc(tc.Data, context)
		}

		//Do verification if VerifyTestFunc is not nil
		equal := false
		if tc.VerifyTestFunc != nil {
			t.Log("VerifyTest Result by VerifyTestFunc")
			equal = tc.VerifyTestFunc(tc.Data, context)
		} else {
			t.Log("No VerifyTestFunc specified, not verify the result this time")
			equal = true
		}

		if !equal {
			t.Fatalf("VerifyTestFunc failed. Please check log.")
		}

	}
}

//Get OS environment, if not exists, return the default Value
func GetOSEnv(name string, defaultValue string) string {
	value := os.Getenv(name)
	if len(value) == 0 {
		value = defaultValue
	}
	return value
}

//Set OS environment
func SetOSEnv(name string, value string) error {
	err := os.Setenv(name, value)
	return err
}
